package mj_compiler;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;


parser code {:
	
	int printCallCount = 0;
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


init with {:
	Tab.init(); // Universe scope
:}

action code {:
	Obj currentMethod = null;
	boolean returnFound = false;
:}

terminal PROG, BREAK, CONST, READ, STATIC, SEMI, COMMA, PRINT, RETURN, VOID, DOT;
terminal CLASS, EXTENDS, NEW ;
terminal FOR, CONTINUE ;
terminal Integer NUMBER ;
terminal Character CHAR ;
terminal Boolean BOOL ;
terminal String IDENT ;
terminal IF, ELSE ;
terminal PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, GT, GEQ, LT, LEQ, AND, OR, PLUSPLUS, MINUSMINUS ;
terminal LBRACE, RBRACE, LBRACK, RBRACK, LPAREN, RPAREN ;
terminal ASSIGN, ASSIGNPLUS, ASSIGNMINUS, ASSIGNMUL, ASSIGNDIV, ASSIGNMOD ; 

non terminal Program ;

Program ::= PROG ;  