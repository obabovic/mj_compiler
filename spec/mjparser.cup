package mj_compiler;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import utils.ParserActionImplementer;

// import java.io.*;


parser code {:	
    int printCallCount = 0;

    Logger log = Logger.getLogger(getClass());
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error : ", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Error : parsing has to be stopped", cur_token);
    }

    public void report_error(String message, Object info) {
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
                System.err.println("Error : on line " + ((Symbol)info).left);
      else System.err.println("");
    }
:}


action code {:
    ParserActionImplementer impl = new ParserActionImplementer() ;	
:}


init with {:
  Tab.init(); 
:}


scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
            log.info(s.toString() + " " + s.value.toString());
    return s;
:}

terminal PROG, STATIC, CONTINUE, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, VOID, LBRACK, RBRACK, READ, BREAK;
terminal IF, ELSE;
terminal CLASS, EXTENDS, CONST;
terminal Character CHAR;
terminal Boolean BOOL;
terminal Integer NUMBER ;
terminal String IDENT ;
terminal INC, DEC, FOR, OR, AND, NEQ, GT, GEQ, LT, LEQ, DOT, NEW, EQ;
terminal ASSIGN, ASSIGNPLUS, ASSIGNMINUS, ASSIGNMUL, ASSIGNDIV, ASSIGNMOD ;
terminal ADD, SUB, MUL, DIV, MOD;
non terminal Program, ProgramName, GlobalParameterList, MethodList ;
non terminal GlobalParameterType ;
non terminal ConstDecl, ConstList, Constant, ConstAdditionalList, ConstType ;
non terminal VarDecl, VarList, Var ; 
non terminal ClassDecl, ClassExtended, ClassVarDecl, ClassMethodList, ClassVarList, ClassVar ;
non terminal MethodDecl, MethodStatic, MethodReturnType, FormPars, MethodVarDecl, FormalParamList, FormalParamDecl;
non terminal Type ;
non terminal StatementList, Statement, StatementMatched, StatementUnmatched, ForStatement, ReadStatement, PrintStatement, ReturnStatement;
non terminal DesignatorStatement, Designator, DesignatorExtension, DesignatorActParsOptional, ActPars ;
non terminal PrintExtension ; 
non terminal ForStatementDesignatorExtension, ForStatementConditionExtension ;
non terminal Condition, ConditionTerm, ConditionFact ;
non terminal IfStatement, IfCondition ;
non terminal Expr, ExprList;
non terminal Relop, Assignop, Addop, AddopLeft, AddopRight, Mulop, MulopLeft, MulopRight ; 
non terminal IdentList, IdentDecl ;
non terminal TermList, Term, FactorList, Factor ;

precedence left ELSE;

//GLOBAL -----------------------------------------------------------------------
Program ::=     PROG ProgramName:pName GlobalParameterList LBRACE MethodList RBRACE ;


ProgramName ::= IDENT ;


GlobalParameterList ::= 
                GlobalParameterList GlobalParameterType 
        |       /* epsilon */ ;


GlobalParameterType ::=    
                ConstDecl
        |       VarDecl 
        |       ClassDecl ;
//------------------------------------------------------------------------------


//CONSTANT ---------------------------------------------------------------------
ConstDecl ::=   CONST Type ConstList SEMI ;


ConstList ::=   Constant ConstAdditionalList ;


ConstAdditionalList ::= 
                COMMA Constant ConstAdditionalList 
        |       /* epsilon */;


Constant ::=    IDENT ASSIGN ConstType ;


ConstType ::=   
                NUMBER 
        |       CHAR 
        |       BOOL ;
//------------------------------------------------------------------------------


//VARIABLE ---------------------------------------------------------------------
VarDecl ::=     Type VarList SEMI ;


VarList ::=     Var COMMA VarList 
        |       Var 
        |       error 
        |       error COMMA VarList ;


Var ::=         IDENT 
        |       IDENT LBRACK RBRACK ;


Type ::=        IDENT ;
//------------------------------------------------------------------------------



//CLASS ------------------------------------------------------------------------
ClassDecl ::=   CLASS IDENT ClassExtended LBRACE ClassVarDecl ClassMethodList RBRACE ;


ClassExtended ::=   
                EXTENDS Type 
        |       /* epsilon */ ;

				  
ClassVarDecl ::=    
                Type ClassVarList SEMI
        |       /* epsilon */ ;


ClassVarList ::=   
                ClassVar COMMA ClassVarList 
        |       ClassVar 
        |       error 
        |       error COMMA ClassVarList ;


ClassVar ::=    IDENT 
        |       IDENT LBRACK RBRACK ;
	
			 
ClassMethodList ::= 
                LBRACE MethodList RBRACE 
        |       /* epsilon */ ;
//------------------------------------------------------------------------------


//METHOD -----------------------------------------------------------------------
MethodList ::=  MethodList MethodDecl 
        |       /* epsilon */ ;

					
MethodDecl ::=  MethodStatic MethodReturnType LPAREN FormPars RPAREN MethodVarDecl LBRACE StatementList RBRACE ;


MethodStatic ::=    
                STATIC 
        |       /* epsilon */ ;


MethodReturnType ::=    
                Type IDENT 
        |       VOID IDENT 
        |       IDENT; 					 


FormPars ::=    FormalParamList
        |       /* epsilon */ ;


FormalParamList ::= 
                FormalParamDecl COMMA FormalParamList 
        |       FormalParamDecl ;
	
				
FormalParamDecl ::= 
                Type IDENT 
        |       Type IDENT LBRACK RBRACK ;


MethodVarDecl ::=   
                VarDecl 
        |       /* epsilon */ ; 
//------------------------------------------------------------------------------


//STATEMENT --------------------------------------------------------------------
StatementList ::=   
                StatementList Statement 
        |       /* epsilon */ ;


Statement ::=   StatementMatched 
        |       StatementUnmatched ;
	  

StatementMatched ::=    
                ForStatement 
        |       DesignatorStatement SEMI    
        |       PrintStatement SEMI 
        |       ReturnStatement SEMI 
        |       ReadStatement SEMI 
        |       CONTINUE SEMI 
        |       BREAK SEMI ;


StatementUnmatched ::=  
                LBRACE StatementList RBRACE 
        |       IfStatement ;
//------------------------------------------------------------------------------


//DESIGNATOR STATEMENT ---------------------------------------------------------
DesignatorStatement ::= 
                Designator:des DesignatorExtension ;


Designator ::=  IdentList ;


DesignatorExtension ::= 
                Assignop Expr 
        |       LPAREN DesignatorActParsOptional RPAREN 
        |       INC 
        |       DEC ;


DesignatorActParsOptional ::=  
                ActPars 
        |       /* epsilon */ ;
//------------------------------------------------------------------------------


//PRINT STATEMENT --------------------------------------------------------------
PrintStatement ::= 
                PRINT LPAREN Expr PrintExtension RPAREN ;


PrintExtension ::=  
                COMMA NUMBER 
        |       /* epsilon */ ;
//------------------------------------------------------------------------------


//RETURN STATEMENT -------------------------------------------------------------
ReturnStatement ::= 
                RETURN 
        |       RETURN Expr ;
//------------------------------------------------------------------------------		   


//READ STATEMENT ---------------------------------------------------------------
ReadStatement ::= 
                READ LPAREN Designator RPAREN ;
//------------------------------------------------------------------------------


//FOR STATEMENT ----------------------------------------------------------------
ForStatement ::= 
                FOR LPAREN ForStatementDesignatorExtension SEMI ForStatementConditionExtension SEMI ForStatementDesignatorExtension RPAREN Statement ;


ForStatementDesignatorExtension ::= 
                DesignatorStatement 
        |       /* epsilon */ ;


ForStatementConditionExtension ::=  
                Condition 
        |       /* epsilon */ ;
//------------------------------------------------------------------------------


//IF ELSE STATEMENT ------------------------------------------------------------
IfStatement ::=     
                IfCondition Statement ELSE Statement 
        |       IfCondition Statement;


IfCondition ::=     IF LPAREN Condition RPAREN;


Condition ::=       
                ConditionTerm 
        |       ConditionTerm OR Condition ;

 			   
ConditionTerm ::=   
                ConditionFact 
        |       ConditionFact  AND ConditionTerm ;
 		
		   
ConditionFact ::=   
                Expr 
        |       Expr Relop Expr ;
//------------------------------------------------------------------------------



//IDENT, EXPR ------------------------------------------------------------------
IdentList ::=   IdentDecl 
        |       IdentList DOT IdentDecl ;

		   	  
IdentDecl ::=   IDENT 
        |       IDENT LBRACK Expr RBRACK ;


ExprList ::=    Expr 
        |       Expr COMMA ExprList ;			  

			  
Expr ::=        TermList 
        |       SUB TermList ;


ActPars ::=     ExprList;		 

	 
TermList ::=    Term 
        |       Term Addop TermList ;		 


Term ::=        FactorList ;


FactorList ::=  Factor 
        |       FactorList Mulop Factor ;


Factor ::=      NUMBER 
        |       Designator 
        |       Designator LPAREN ActPars RPAREN 
        |       Designator LPAREN RPAREN 
        |       CHAR 
        |       BOOL 
        |       LPAREN Expr RPAREN 
        |       NEW Type LBRACK Expr RBRACK 
        |       NEW Type ;
//------------------------------------------------------------------------------


//OPERATION --------------------------------------------------------------------
Relop ::=       EQ 
        |       NEQ 
        |       GT
        |       GEQ 
        |       LT 
        |       LEQ ; 


Assignop ::=    ASSIGN 
        |       AddopRight 
        |       MulopRight ;


Addop ::=       AddopLeft 
        |       AddopRight ;


AddopLeft ::=   ADD 
        |       SUB ;


AddopRight ::=  ASSIGNPLUS 
        |       ASSIGNMINUS ;


Mulop ::=       MulopLeft 
        |       MulopRight ;


MulopLeft ::=   MUL 
        |       DIV 
        |       MOD ;


MulopRight ::= ASSIGNMUL | ASSIGNDIV | ASSIGNMOD ;
//------------------------------------------------------------------------------